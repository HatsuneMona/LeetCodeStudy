/*
912. 排序数组
给你一个整数数组 nums，请你将该数组升序排列。

示例 1：							示例 2：
	输入：nums = [5,2,3,1]			输入：nums = [5,1,1,2,0,0]
	输出：[1,2,3,5]					输出：[0,0,1,1,2,5]

提示：
	1 <= nums.length <= 50000
	-50000 <= nums[i] <= 50000
*/
package main

import (
	"20.leecode/tools"
)

func main() {
	test := []int{-74, 48, -20, 2, 10, -84, -5, -9, 11, -24, -91, 2, -71, 64, 63, 80, 28, -30, -58, -11, -44, -87, -22, 54, -74, -10, -55, -28, -46, 29, 10, 50, -72, 34, 26, 25, 8, 51, 13, 30, 35, -8, 50, 65, -6, 16, -2, 21, -78, 35, -13, 14, 23, -3, 26, -90, 86, 25, -56, 91, -13, 92, -25, 37, 57, -20, -69, 98, 95, 45, 47, 29, 86, -28, 73, -44, -46, 65, -84, -96, -24, -12, 72, -68, 93, 57, 92, 52, -45, -2, 85, -63, 56, 55, 12, -85, 77, -39}
	need := []int{-96, -91, -90, -87, -85, -84, -84, -78, -74, -74, -72, -71, -69, -68, -63, -58, -56, -55, -46, -46, -45, -44, -44, -39, -30, -28, -28, -25, -24, -24, -22, -20, -20, -13, -13, -12, -11, -10, -9, -8, -6, -5, -3, -2, -2, 2, 2, 8, 10, 10, 11, 12, 13, 14, 16, 21, 23, 25, 25, 26, 26, 28, 29, 29, 30, 34, 35, 35, 37, 45, 47, 48, 50, 50, 51, 52, 54, 55, 56, 57, 57, 63, 64, 65, 65, 72, 73, 77, 80, 85, 86, 86, 91, 92, 92, 93, 95, 98}
	tools.IsArrEqual(sortArray(test), need)
}

func sortArray(nums []int) []int {
	if len(nums) < 2 {
		return nums
	}
	//Quick Sort
	//第一步：定义基准值（的指针位置）。
	baseP := 0     //基准值的位置（指针），有这个指针纯属为了让思路清晰一些，可以忽略这个
	lessCount := 0 //小于基准值的元素的数量
	//moreCount := 0 //多于基准值元素的数量
	//第二步：遍历数组，对小于、大于基准值的数进行分类。
	//小于基准值的数放到基准值的左面，大于基准值的放到基准值的右面。
	for i := 0; i < len(nums); i++ {
		if nums[i] < nums[baseP] { //对于所有小于基准值的数，放到基准值的左面
			//先将左右小于基准值的数，放到数组前半部分。
			lessCount++ //将统计量+1，此时代表了当下新发现的小元素要被存放的位置。
			if i != lessCount {
				nums[i], nums[lessCount] = nums[lessCount], nums[i] //进行交换。
			} //如果i == lessCount，说明不需要交换位置。此时交换等式无意义。
			/*【此处作废】
			////特殊情况：基准值左面，没有位置存放小于基准值的数。
			//if baseP==0 {
			//	nums[baseP], nums[baseP+1] = nums[baseP+1], nums[baseP] //将基准值，与后一位的元素，交换位置。
			//	baseP++                                                 //更新基准值的指针
			//	nums[baseP-1], nums[i] = nums[i], nums[baseP-1]         //将通过循环找到的小于基准值的数，跟基准值前面一位的数，进行交换
			//}*/
		}
		// if nums[i] == nums[baseP] 不进行任何操作，跟基准值相同的数，可以放到任何一边
		// if nums[i] > nums[baseP] 不进行任何操作，只需要把小于基准值的数分类好，大于基准值的数自然而然地就被分好类了。
	}
	//当统计完小元素后，将基准值放到小元素后方。
	//即：将基准值与小元素最后一位交换位置
	nums[baseP], nums[lessCount] = nums[lessCount], nums[baseP]
	baseP = lessCount //更新基准值的位置（指针）
	//mux := sync.WaitGroup{}
	if lessCount > 1 {
		//mux.Add(1) //在创建线程之前，先mux.Add(1)，是正确的。
		//go func() {
		sortArray(nums[:baseP])
		//mux.Done()
		//}()
	}
	if len(nums)-lessCount > 1 {
		//mux.Add(1)
		//go func() {
		//mux.Add(1)//如果把mux.Add(1)放到这里，错误！线程还没创建完，主线程已经跑完了，导致mux.Wait()失效。
		sortArray(nums[baseP+1:])
		//mux.Done()
		//}()
	}
	//mux.Wait()
	return nums
}

//用多线程，在处理的时候反而更慢了
//单线程：	通过	20 ms	6.2 MB	 Go
//多线程：	通过	56 ms	13.4 MB	 Go
