func sortArray(nums []int) []int {
	if len(nums) < 2 {
		return nums
	}
	//Quick Sort
	//第一步：定义基准值（的指针位置）。
	baseP := 0     //基准值的位置（指针），有这个指针纯属为了让思路清晰一些，可以忽略这个
	lessCount := 0 //小于基准值的元素的数量
	//moreCount := 0 //多于基准值元素的数量
	//第二步：遍历数组，对小于、大于基准值的数进行分类。
	//小于基准值的数放到基准值的左面，大于基准值的放到基准值的右面。
	for i := 0; i < len(nums); i++ {
		if nums[i] < nums[baseP] { //对于所有小于基准值的数，放到基准值的左面
			//先将左右小于基准值的数，放到数组前半部分。
			lessCount++ //将统计量+1，此时代表了当下新发现的小元素要被存放的位置。
			if i != lessCount {
				nums[i], nums[lessCount] = nums[lessCount], nums[i] //进行交换。
			} //如果i == lessCount，说明不需要交换位置。此时交换等式无意义。
		}
		// if nums[i] == nums[baseP] 不进行任何操作，跟基准值相同的数，可以放到任何一边
		// if nums[i] > nums[baseP] 不进行任何操作，只需要把小于基准值的数分类好，大于基准值的数自然而然地就被分好类了。
	}
	//当统计完小元素后，将基准值放到小元素后方。
	//即：将基准值与小元素最后一位交换位置
	nums[baseP], nums[lessCount] = nums[lessCount], nums[baseP]
	baseP = lessCount //更新基准值的位置（指针）
	// mux := sync.WaitGroup{}
	if lessCount > 1 {
		// mux.Add(1) //在创建线程之前，先mux.Add(1)，是正确的。
		// go func() {
			sortArray(nums[:baseP])
			// mux.Done()
		// }()
	}
	if len(nums)-lessCount > 1 {
		// mux.Add(1)
		// go func() {
			//mux.Add(1)//如果把mux.Add(1)放到这里，错误！线程还没创建完，主线程已经跑完了，导致mux.Wait()失效。
			sortArray(nums[baseP+1:])
			// mux.Done()
		// }()
	}
	// mux.Wait()
	return nums
}

//runtime:20 ms
//memory:6.2 MB
